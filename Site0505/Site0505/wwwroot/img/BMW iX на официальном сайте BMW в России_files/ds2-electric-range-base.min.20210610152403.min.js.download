/**
 * @module ds2-electric-range
 * @description Electric Range Component with Tab Navigation
 * @author Patrick Rathke
 */

define(
    'ds2-electric-range',
    [
        'lazyload',
        'ds2-text-direction',
        'ds2-touch-detection',
        'ds2-electric-range-map',
        'ds2-electric-range-util',
        'ds2-electric-range-accessibility',
        'ds2-electric-range-calculator'
    ],
    function (LazyLoad, Dir, touchDevice, DS2ElectricRangeMap, DS2ElectricRangeUtil, Accessibility, ElectricRangeCalculator) {
        'use strict';

        /**
         * Create a new Electric Range                                                                                                                                                                                                                                                                                                            Component.
         * @alias module: ds2-electric-range
         * @param {HTMLElement} element - the component element.
         * @constructor
         */
        function DS2ElectricRange(element) {
            var self = this;

            /**
             * component context
             * @type {HTMLElement} this component element
             */
            self.element = element;
            self.rangeCalculator = new ElectricRangeCalculator();

            /**
             * component elements
             * @type {{next: *, slider: *, item: *, mapContainer: *, prev: *, cta: *, track: *}}
             */
            self.elements = {
                body: document.getElementsByTagName('body')[0],
                cta: element.querySelectorAll('.ds2-electric-range__model-card-cta'),
                item: element.querySelectorAll('.ds2-electric-range__slider-item'),
                mapContainer: element.querySelector('.ds2-electric-range__map-wrapper'),
                next: element.querySelector('[data-action="next"]'),
                prev: element.querySelector('[data-action="prev"]'),
                slider: element.querySelector('.ds2-electric-range__slider'),
                track: element.querySelector('.ds2-electric-range__slider-track'),
                openLayer: element.querySelector('.ds2-electric-range__layer-open'),
                closeLayer: element.querySelector('.ds2-electric-range__layer-close'),
                layer: element.querySelector('.ds2-electric-range__layer'),
                selectedCar: element.querySelector('.ds2-electric-range__model-card-selected-car'),
                itemLayer: element.querySelectorAll('.ds2-electric-range__layer-item'),
                conButton: element.querySelectorAll('.ds2-electric-range__con-button'),
                techDataButton: element.querySelectorAll('.ds2-electric-range__model-card-techbutton'),
                toggleProfile: element.querySelectorAll('.ds2-electric-range__driving-profile-range input'),
                temperatureCondition: element.querySelectorAll('.ds2-electric-range__temperature-range input'),
                airConditioning: element.querySelectorAll('.ds2-electric-range__switch-wrapper input')
            };

            /**
             * component & slider options
             * @type {{animationTiming: number, count: number, current: number, dir: string, last: number, offset: number, rtl: boolean, scrollDiff: number, scrollPosition: (Number|number), smallBreak: number, timeout: {}, touch: boolean, width: number}}
             */
            self.options = {
                animationTiming: 500,
                count: self.elements.item.length,
                current: 0,
                conLink: self.elements.conButton[0] ? self.elements.conButton[0].dataset.conLink : '',
                techDataLink: self.elements.techDataButton[0] ? self.elements.techDataButton[0].dataset.techdataLink : '',
                dir: 'next',
                last: 0,
                maxRange: {
                    electric: 0
                },
                offset: self.elements.item[0] ? self.elements.item[0].offsetLeft*-1 : 0,
                rangeData: [
                    {
                        minRange: 0,
                        maxRange: 0,
                        html: '',
                        rangeUnit: '',
                    }
                ],
                rtl: !Dir.isLTR,
                scrollDiff: 0,
                scrollPosition: window.scrollY || window.pageYOffset || document.documentElement.scrollTop,
                smallBreak: 520,
                timeout: {},
                touch: touchDevice.any,
                usedMap: self.elements.mapContainer ? self.elements.mapContainer.dataset.usedMap : '',
                width: self.element.clientWidth
            };

            /**
             * modifier classes
             * @type {{active: string, empty: string, expanded: string, first: string, grabbing: string, last: string, single: string, sliding: string, sticky: string, stickyBottom: string, stickyTop: string, touch: string, visible: string}}
             */
            self.classes = {
                active: 'is-active',
                empty: 'is-empty',
                expanded: 'is-expanded',
                first: 'is-first',
                grabbing: 'is-grabbing',
                last: 'is-last',
                single: 'is-single',
                sliding: 'is-sliding',
                sticky: 'is-sticky',
                stickyBottom: 'is-sticky-bottom',
                stickyTop: 'is-sticky-top',
                touch: 'is-touch',
                visible: 'is-visible',
                scrollLock: 'ds2-scrolllock'
            };

            /**
             * Add utilities from shared helper module
             */
            self.util = new DS2ElectricRangeUtil(self.element, self.classes);

            /**
             * setup single item
             * if component has only one item
             */
            if (self.options.count === 1) {
                self.setupSingleItem();
                self.setupEvents();
                self.setupMapData();
                self.setupStickyBar();
                self.updateStickyBarPosition();
                self.initRangeSlider();
                self.initSelectedItem();
                self.initSwitches();
                self.util.trackEvent({element: self.elements.item[0]});
                self.updateActivityMapTracking();
            }
            /**
             * clone slides / add events / setup sticky mobile header bar / init slider / init selected item in mobile
             * if component has more than one item
             */
            else if (self.options.count >= 2) {
                self.setupDataTarget();
                self.setupEvents();
                self.setupSwipe();
                self.setupMapData();
                self.setupStickyBar();
                self.updateStickyBarPosition();
                self.slideTo(self.options.current, true, true);
                self.initRangeSlider();
                self.initSelectedItem();
                self.initSwitches();
                self.util.trackEvent({element: self.elements.item[0]});
            }
            /**
             * no items
             * if component has no items at all add special modifier class
             */
            else {
                self.util.setClass(self.element, {empty: true});
            }

            /**
             * Set up extra touch class for all cases and init img lazy loading
             */
            self.util.setClass(self.element, {touch: self.options.touch});
            new LazyLoad({container: self.element});

            /**
             * Add new map to container element
             */
            if (self.options.usedMap) {
                self.map = new DS2ElectricRangeMap(self.elements.mapContainer, self.options.usedMap, self.options.rangeData[0], self.options.maxRange, self.util);
            }

            self.accessibility = new Accessibility(element, self.map);
            self.setConLink(0);
            self.setTechDataLink(0);
            self.calculateRange();
        }

         /**
         * Calculate Range
         * collects all user settings and calls the getRange function and sets the new Range on the map.
         */
        DS2ElectricRange.prototype.calculateRange = function () {
            var self = this;
            var modelCode = self.elements.item[self.options.current].dataset.originalCode;
            var profile = document.querySelectorAll("input[name='drivingProfile']")[0].value;
            var temperature = document.querySelectorAll("input[name='outsideTemperature']")[0].value;
            var climatisation = document.querySelectorAll("input[name='airconditioning']")[0].checked;
            var precondition = false;
            self.rangeCalculator.getRange(modelCode, parseInt(profile), parseInt(temperature), climatisation, precondition).done(function (data){
                if (typeof data === 'number') {
                    self.options.rangeData[self.options.current].minRange = data;
                    self.options.rangeData[self.options.current].maxRange = data;
                    self.map.updateRangeOnMap(self.options.rangeData[self.options.current]);
                }
            })
        }

        /**
         * Set Con Link
         * sets the con link to the button, if the con button is activated.
         * @param {Integer} current - the position of the current selected car
         */
        DS2ElectricRange.prototype.setConLink = function (current) {
            var self = this;
            // check if the con link is activated and rendered
            if (self.elements.conButton.length > 0) {

                // getting all needed variables to setup the new con link
                var conURL = this.options.conLink;
                var sliderElement = this.elements.item[current];
                var modelRangeCode = sliderElement.dataset.modelRange;
                var modelCode = sliderElement.dataset.productId;

                /**
                 * as we do have a multistep version of the con link, not all markets will have
                 * modelRangeCode and modelCode in there con links.
                 * Therefore we have to check if these variables are availaable in the link and
                 * replace them with the correct values
                 */
                if (conURL && conURL.includes('${modelRangeCode}')) {
                    conURL = conURL.replace('${modelRangeCode}', modelRangeCode);
                }
                if (conURL && conURL.includes('${modelCode}')) {
                    conURL = conURL.replace('${modelCode}', modelCode);
                }

                // setting the link to the button
                // we need a forEach, because we have 2 buttons (mobile and the other viewports)
                // make button tabbable
                self.elements.conButton.forEach(function (button) {
                    button.href = conURL;
                    self.accessibility.makeElementActive(button);
                })
            }
        };

        DS2ElectricRange.prototype.setTechDataLink = function (current) {
            var self = this;
            // check if the con link is activated and rendered
            if (self.elements.techDataButton.length > 0) {
                // getting all needed variables to setup the new con link
                var sliderElement = this.elements.item[current];
                var techDataURL = sliderElement.dataset.techdataLink;

                // setting the link to the button
                // we need a forEach, because we have 2 buttons (mobile and the other viewports)
                // make button tabbable
                self.elements.techDataButton.forEach(function (button) {
                    if (techDataURL && techDataURL != '') {
                        button.href = techDataURL;
                        button.removeAttribute('style');
                        self.accessibility.makeElementActive(button);
                    } else {
                        button.setAttribute('style', 'visibility: hidden;');
                    }
                })
            }
        };

        /**
         * Init Switches
         * set up the switches for user interaction
         */
        DS2ElectricRange.prototype.initSwitches = function () {
            var self = this;
            var allSwitches = document.querySelectorAll(".ds2-electric-range__switch");
            allSwitches[0].setAttribute("data-tracking-options", '');
            allSwitches.forEach(function (singleSwitch) {
                singleSwitch.addEventListener("change", function (e) {
                    document.querySelectorAll("[name = " + singleSwitch.getAttribute('name') + "]").forEach(function (element) {
                        if (element.checked != singleSwitch.checked) {
                            element.checked = singleSwitch.checked;
                        }
                    })
                    self.calculateRange();
                });
            });
        };

        "use strict";

        /**
         * Init Range Slider
         * set up the range slider and update all needed values after user interaction
         */
        DS2ElectricRange.prototype.initRangeSlider = function () {
            var self = this,
                allRanges = self.element.querySelectorAll(".electric-range-slider");
            allRanges.forEach(function (wrap) {
                var range = wrap.querySelector(".electric-range-slider__slider");
                var min = range.min ? range.min : 0;
                var max = range.max ? range.max : 100;
                var step = range.step ? range.step : 1;
                var steps = (max - min) / step;
                var name = range.getAttribute('name');
                var bubble = wrap.querySelector(".electric-range-slider__bubble") || null;
                var left = wrap.querySelector(".custom-track-left");
                var right = wrap.querySelector(".custom-track-right");
                var customTrack = wrap.querySelector(".electric-range-slider__custom-track");

                // the slider needs to get updated if the user changes the value.
                range.addEventListener("input", function () {
                    setBubble(range, left, bubble);
                    setCircles(range, right, customTrack.offsetWidth / steps - 4);
                    self.element.querySelectorAll("[name=" + name + "]").forEach(function (input) {
                        if (input.value != range.value) {
                            input.value = range.value;
                        }
                    })
                    self.calculateRange();
                });

                // updates slider if the viewport changes
                window.addEventListener('resize', function() {
                    setBubble(range, left, bubble);
                    setCircles(range, right, customTrack.offsetWidth / steps - 4);
                });

                // init the slider settings
                setBubble(range, left, bubble);
                setCircles(range, right, customTrack.offsetWidth / steps - 4);
            });

            /**
             * This function sets the cirles for the right part of the customtrack
             * element of the slider. This is not possible with css so it needs to
             * be updated with js
             *
             * @param {element} range - the range input element
             * @param {element} right - the right part of the custom-track
             * @param {int} margin - the calculated margin value which each cirle needs to have
             **/
            function setCircles(range, right, margin) {
                var val = range.value;
                var min = range.min ? range.min : 0;
                var max = range.max ? range.max : 100;
                var step = range.step ? range.step : 1;

                // calculate the steps which are open
                var openSteps = (max - val) / step;
                // remove all existing svgs from the right part of the custom track
                right.innerHTML = "";

                // for each open step create a svg and add it to the right part of the custom track
                while (openSteps--) {
                    var svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                    svg.setAttribute("viewBox", "0 0 200 200");
                    svg.setAttribute("class", "svg");
                    svg.setAttribute("style", "margin-left: " + margin + "px");
                    var circle = document.createElementNS(
                    "http://www.w3.org/2000/svg",
                    "circle"
                    );
                    circle.setAttribute("fill", "#E6E6E6");
                    circle.setAttribute("cy", "100");
                    circle.setAttribute("cx", "100");
                    circle.setAttribute("r", "100");
                    svg.appendChild(circle);
                    right.appendChild(svg);
                }
            }

            /**
             * This function sets the position of the value bubble and updates
             * also the value of the bubble itself to show the selected value
             *
             * @param {element} range - the range input element
             * @param {element} bubble - the element which appears over the range slider and shows the current selected value
             * @param {element} left - the left part of the custom-track
             **/
            function setBubble(range, left) {
                var bubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
                var val = range.value;
                var min = range.min ? range.min : 0;
                var max = range.max ? range.max : 100;
                var newVal = Number((val - min) * 100 / (max - min));

                if (bubble) {
                    bubble.innerHTML = val + '°';
                    bubble.style.left = "calc(".concat(newVal, "% + (").concat(8 - newVal * 0.15, "px))");
                }

                // Sorta magic numbers based on size of the native UI thumb
                if(newVal === 100) {
                    left.style.width = "calc(".concat(newVal, "% - (", 8, "px))");
                } else {
                left.style.width = "calc(".concat(newVal, "%)");
                }
            }
        };

        /**
         * Init Selected item
         * get first item from the list of items
         */
        DS2ElectricRange.prototype.initSelectedItem = function() {
            var self = this;

            var itemClone = self.elements.itemLayer[0].querySelector('.ds2-electric-range__model-card').cloneNode(true);
            var cardTitle = itemClone.querySelector('.ds2-electric-range__model-card-title').classList;
            cardTitle.remove('ds2-font-xs');
            cardTitle.add('ds2-font-s-bolder');
            itemClone.querySelector('.ds2-electric-range__model-card-range').remove();
            if (itemClone.querySelector('.ds2-electric-range__model-card-new-label')) {
                itemClone.querySelector('.ds2-electric-range__model-card-new-label').remove();
            }
            self.elements.selectedCar.prepend(itemClone);
        }

        /**
         * Set up single item
         * if only one item slider is not needed and unused elements are removed
         */
        DS2ElectricRange.prototype.setupSingleItem = function() {
            var self = this;

            // save item as nodelist to be used by other methods
            self.elements.item = self.elements.track.querySelectorAll('.ds2-electric-range__slider-item');

            // add single class to component
            self.util.setClass(self.element, {single: true});

            // set single item active and visible
            self.util.setClass(self.elements.item[0], {active: true, visible: true});

            // remove arrows for single item
            self.elements.prev.style.display = "none";
            self.elements.next.style.display = "none";
        };

        DS2ElectricRange.prototype.setupDataTarget = function() {
            var self = this;
            //REF: this can be later removed because we have no bookmarks
            self.elements.all = self.elements.track.querySelectorAll('.ds2-electric-range__slider-item');
            for (var a = 0 ; a < self.elements.all.length; a++) {
                var all = self.elements.all[a];
                all.dataset.target = a;
                // set data-target on layer items
                self.elements.itemLayer[a].dataset.target = a;
            }
        };

        /**
         * Create Event Listeners
         * for clicking elements, resize and scroll
         */
        DS2ElectricRange.prototype.setupEvents = function() {
            var self = this;

            if (self.options.count > 1) {
                // set click listener for next button
                self.elements.next.addEventListener('click', function () {
                    if(self.options.current + 1 === self.options.count - 1) {
                        self.accessibility.focusElement(self.elements.prev);
                    }
                    self.slideTo(self.options.current + 1);
                    self.setConLink(self.options.current);
                    self.setTechDataLink(self.options.current);
                    self.updateActivityMapTracking();
                    self.util.trackEvent({element: this, additionalData: false});
                }, false);

                // set click listener for prev button
                self.elements.prev.addEventListener('click', function () {
                    if(self.options.current - 1 === 0) {
                        self.accessibility.focusElement(self.elements.next);
                    }
                    self.slideTo(self.options.current - 1);
                    self.setConLink(self.options.current);
                    self.setTechDataLink(self.options.current);
                    self.updateActivityMapTracking()
                    self.util.trackEvent({element: this, additionalData: false});
                }, false);

                // set click listener for visible icons

                for (var a = 0; a < self.elements.all.length; a++) {
                    self.elements.all[a].addEventListener('click', function () {
                        if (this.classList.contains('is-visible')) {
                            self.slideTo(this.dataset.target * 1);
                        }
                    }, false);
                }
            }
            //adds eventTracking to driving profile, outside temperature and air conditioning
            self.elements.airConditioning.forEach((element) => {
                element.addEventListener('click', function () {
                    var value = this.checked ? true : false;

                    self.util.trackEvent({
                        element: this,
                        eventInfo: {
                            effect: value === true ? 'nsc > toggle air conditioning on' : 'nsc > toggle air conditioning off',
                            eventAction:"toggle"},
                        category: {
                            subCategory1: value === true ? 'true' : 'false'},
                        additionalData: false
                    });
                });
            });

            self.elements.toggleProfile.forEach((element) => {
                element.addEventListener('click', function () {
                    var value = this.value;
                    self.util.trackEvent({
                        element: this,
                        eventInfo: {
                            effect: "nsc > change filter driving behavior"},
                        category: {
                            subCategory1: value},
                        additionalData: false
                    });
                });
            });

            self.elements.temperatureCondition.forEach((element) => {
                element.addEventListener('click', function () {
                    var value = this.value;
                    self.util.trackEvent({
                        element: this,
                        eventInfo: {
                            effect: "nsc > change filter temperature"},
                        category: {
                            subCategory1: value},
                        additionalData: false
                    });
                });
            });

            // set click listener for call to actions
            for (var c = 0; c < self.elements.cta.length; c++) {
                self.elements.cta[c].addEventListener('click', function () {
                    var target = this.getAttribute('href'),
                        absolute = (target.indexOf('://') > 0 || target.indexOf('//') === 0),
                        sameHost = target.indexOf(window.location.host) !== -1;

                    self.util.trackEvent({
                        element: this,
                        eventInfo: {
                            eventAction: absolute && !sameHost ? 'outbound click' : 'internal click',
                            target: target
                        }
                    });
                }, false);
            }

            // adds select item from layer listener
            for (var c = 0; c < self.elements.itemLayer.length; c++) {
                self.elements.itemLayer[c].addEventListener('click', function () {
                    if (self.elements.itemLayer.length > 1) {
                        self.selectItem(this, this.dataset.target * 1);
                    } else {
                        self.closeLayer();
                    }
                });
            }
            // adds open layer listener
            self.elements.openLayer.addEventListener('click', function() {
                self.openLayer();
            })

            // adds close layer listener
            self.elements.closeLayer.addEventListener('click', function() {
                self.closeLayer();
            })

            // adds resize listener
            window.addEventListener('resize', function(){
                self.resizeHandler();
            });

            // adds scroll listener
            window.addEventListener('scroll', function(){
                self.updateStickyBarPosition();
                var mediaQuery = window.matchMedia('(max-width: 767px)')
                if (mediaQuery.matches) {
                    self.checkPosition();
                }
            });
        };

        /**
         * Re-calculate Slider positions on width change
         * triggered by resize listener
         */
        DS2ElectricRange.prototype.resizeHandler = function() {
            var self = this,
                newWidth = self.element.clientWidth;

            if (self.options.width !== newWidth) {
                self.options.width = newWidth;
                self.elements.slider.style.transition = 'none';
                self.elements.slider.style.opacity = '0';
                clearTimeout(self.options.timeout.resize);
                self.options.timeout.resize = setTimeout(function () {
                    self.setupStickyBar();
                    if (self.options.count > 1) self.slideTo(self.options.current, true);
                    self.elements.slider.style.transition = '';
                    self.elements.slider.style.opacity = '';
                }, self.options.animationTiming);
            }
        };

        /**
         * Re-calculate Sticky Bar position and appearance on scroll for mobile
         * triggered by scroll listener, init or expand/collapse on mobile
         */
        DS2ElectricRange.prototype.updateStickyBarPosition = function() {
            var self = this;

            if (self.elements.stickyBar) {
                var newScroll = window.scrollY || window.pageYOffset || document.documentElement.scrollTop,
                    top = self.util.getOffset(self.elements.slider).top + 90,
                    bottom = self.util.getOffset(self.elements.mapContainer).top - self.elements.stickyBar.clientHeight;

                self.util.setClass(self.elements.stickyBar, {
                    stickyTop: newScroll < top,
                    sticky: newScroll >= top && newScroll < bottom,
                    stickyBottom: newScroll >= bottom,
                    visible: newScroll >= top && self.options.scrollDiff <= 50
                });
                self.options.scrollDiff = self.options.scrollPosition <= newScroll ? 0 : self.options.scrollDiff + self.options.scrollPosition - newScroll;
                self.options.scrollPosition = newScroll;
            }
        };

        /**
         * Open full screen layer for selecting car on mobile
         * Trigger Lazy loading* Set layer elements focusable
         * Set layer elements focusable
         */
        DS2ElectricRange.prototype.openLayer = function() {
            var self = this;

            new LazyLoad({container: self.elements.layer});

            self.elements.body.style.removeProperty('overflow');

            self.util.setClass(self.elements.body, { scrollLock: true });
            self.util.setClass(self.elements.layer, { active: true });

            self.accessibility.makeLayerElementsFocusable(self.options.current);
        }

        /**
         * Close full screen layer on mobile
         * Set layer elements unfocusable
         */
        DS2ElectricRange.prototype.closeLayer = function() {
            var self = this;

            self.util.setClass(self.elements.body, { scrollLock: false });
            self.util.setClass(self.elements.layer, { active: false });

            self.accessibility.makeLayerElementsUnFocusable();
        }

        /**
         * Select item from full screen layer on mobile and remove old one
         * Close layer after selection
         */
        DS2ElectricRange.prototype.selectItem = function(item, index) {
            var self = this,
            itemClone = item.querySelector('.ds2-electric-range__model-card').cloneNode(true),
            cardTitle = itemClone.querySelector('.ds2-electric-range__model-card-title').classList;

            cardTitle.remove('ds2-font-xs');
            cardTitle.add('ds2-font-s-bolder');

            self.options.current = index;

            self.elements.selectedCar.querySelector('.ds2-electric-range__model-card').remove();
            itemClone.querySelector('.ds2-electric-range__model-card-range').remove();

            self.elements.selectedCar.prepend(itemClone);
            self.calculateRange();
            self.util.updateTrackingData(self.elements.item[self.options.current]);
            self.util.trackEvent({element: self.elements.item[self.options.current]});
            self.closeLayer();
        }
        /**
         * Adds Swipe / Drag Navigation for navigation through items
         * by adding touch/mouse listeners
         */
        DS2ElectricRange.prototype.setupSwipe = function() {
            // TODO: add separate DOM element (which shall not be placed over the map) for handling the swipe functionality to prevent unwanted swiping when performing drag & drop on the map widget

            var self = this,
                start = self.options.touch ? 'touchstart' : 'mousedown',
                end = self.options.touch ? 'touchend' : 'mouseup',
                dist, startX, endX;

            // start event for slider
            self.elements.slider.addEventListener(start, function(event) {
                startX = self.options.touch ? event.changedTouches[0].clientX : event.pageX;
                dist = 0;

                self.util.setClass(self.elements.slider, {grabbing: true});
            });
            // end event for slider
            self.elements.slider.addEventListener(end, function(event) {
                endX = self.options.touch ? event.changedTouches[0].clientX : event.pageX;
                dist = endX - startX;

                self.util.setClass(self.elements.slider, {grabbing: false});

                // show prev item
                if ((dist > 50 && !self.options.rtl) || (dist < -50 && self.options.rtl)) {
                    self.slideTo(self.options.current - 1);
                    self.util.trackEvent({
                        element: self.elements.prev,
                        eventInfo: {
                            effect: self.options.rtl ? 'tr > carousel swiped right' : 'tr > carousel swiped left'
                        },
                        additionalData: false
                    });
                }
                // show next item
                else if ((dist < -50 && !self.options.rtl) || (dist > 50 && self.options.rtl)) {
                    self.slideTo(self.options.current + 1);
                    self.util.trackEvent({
                        element: self.elements.next,
                        eventInfo: {
                            effect: self.options.rtl ? 'tr > carousel swiped left' : 'tr > carousel swiped right'
                        },
                        additionalData: false
                    });
                }
            });
        };

        /**
         *
         */
        DS2ElectricRange.prototype.setupMapData = function() {
            var self = this;

            for (var i = 0; i < self.elements.item.length; i++) {
                var item = self.elements.item[i],
                    data;
                if (item) {
                    data = item.dataset.mapRange;
                    if (data) {
                        self.options.rangeData[i] = data = JSON.parse(data.replace(/'/g,'"'));
                        if (parseFloat(data.maxRange) > parseFloat(self.options.maxRange.electric)) {
                            self.options.maxRange.electric = data.rangeUnit === "miles" ? (data.maxRange * (1609.34 / 1000)).toString(10) : data.maxRange;
                        }
                        self.options.rangeData[i].html = item.querySelector('.ds2-electric-range__model-card-range');
                    }
                }
            }
        };

        /**
         * Creates/Destroys clones of all Slides with minimal info about the model
         * that can be a sticky header depending on the scroll position
         */
        DS2ElectricRange.prototype.setupStickyBar = function() {
            var self = this,
                container, slider, track, clone;

            if (self.options.width <= self.options.smallBreak && !self.elements.stickyBar) {
                container = document.createElement("div");
                container.className = 'ds2-electric-range__sticky-bar';
                slider = document.createElement("div");
                slider.className = 'ds2-electric-range__slider';
                track = document.createElement("div");
                track.className = 'ds2-electric-range__slider-track';

                self.elements.base = self.elements.track.querySelectorAll('.ds2-electric-range__model-card-base');
                for (var i = 0; i < self.elements.base.length; i++) {
                    clone = self.elements.base[i].cloneNode(true);
                    clone.className = 'ds2-electric-range__slider-item';
                    track.appendChild(clone);
                }

                slider.appendChild(track);
                container.appendChild(slider);
                self.elements.slider.appendChild(container);

                self.elements.stickyBar = self.element.querySelector('.ds2-electric-range__sticky-bar');
                self.elements.stickyTrack = self.elements.stickyBar.querySelector('.ds2-electric-range__slider-track');
                self.elements.stickyItem = self.elements.stickyBar.querySelectorAll('.ds2-electric-range__slider-item');
            }
            else if (self.elements.stickyBar) {
                self.elements.stickyBar.remove();
                self.elements.stickyBar = self.elements.stickyTrack = self.elements.stickyItem = undefined;
            }

        };

        /**
         * Updates all classes for active/visible visual status feedback
         * triggered after sliding & resize
         */
        DS2ElectricRange.prototype.updateClasses = function() {
            var self = this,
                isActive,
                isVisible;

            for (var i = 0; i < self.elements.item.length; i++) {
                isActive = (i === self.options.current) || i + self.options.count === self.options.current;
                isVisible = (self.options.offset + self.elements.item[i].offsetLeft > 0 && self.options.offset + self.elements.item[i].offsetLeft - self.elements.slider.clientWidth < 0) || (self.options.current >= self.options.count);

                self.util.setClass(self.elements.item[i], {
                    active: isActive,
                    visible: isActive || isVisible
                });
                if (self.elements.stickyBar && self.elements.stickyItem[i]) {
                    self.util.setClass(self.elements.stickyItem[i], {
                        active: isActive,
                        visible: isActive || isVisible
                    });
                }
            }

            self.elements.active = self.elements.item[self.options.current];

            self.util.setClass(self.elements.slider, {
                first: self.options.current <= 0,
                last: self.options.current + 1 >= self.options.count
            });
            self.elements.prev.tabIndex = self.options.current <= 0 ? -1 : 0;
            self.elements.next.tabIndex = self.options.current >= self.options.count - 1 ? -1 : 0;

            if (self.elements.prev.tabIndex === -1) {
                self.elements.prev.style.display = "none";
            } else {
                self.elements.prev.style.display = "block";
            }
            if (self.elements.next.tabIndex === -1) {
                self.elements.next.style.display = "none";
            } else {
                self.elements.next.style.display = "block";
            }

            self.util.setClass(self.elements.slider, {grabbing: false});
        };

        /**
         * Moves the slider to next position
         * with or without animation
         * @param slide
         * @param silent
         */
        DS2ElectricRange.prototype.slideTo = function(slide, silent, init = false) {
            var self = this;
            //
            self.options.last = self.options.current;
            self.options.current = slide;
            if (self.options.last > self.options.count) {
                self.options.last = self.options.last - self.options.count;
            }

            self.options.dir = (self.options.last <= self.options.current) ? 'next' : 'prev';

            if (self.options.dir === 'next') {
                var widthDifferenceDelta = (self.elements.item[self.options.current].clientWidth - self.elements.item[self.options.last].clientWidth);
            }

            else if (self.options.dir === 'prev') {
                var widthDifferenceDelta = (self.elements.item[self.options.current].clientWidth - self.elements.item[0].clientWidth);
            }

            if(widthDifferenceDelta < 0 ){
                widthDifferenceDelta = widthDifferenceDelta * -1;
            }
            self.options.offset = ((self.elements.item[self.options.current].offsetLeft - self.elements.item[0].offsetLeft) - widthDifferenceDelta) * -1;

            self.elements.track.style.transition = silent ? 'none' : '';
            self.elements.track.style.transform = 'translate3d(' + self.options.offset + 'px,0,0)';
            if (self.elements.stickyBar && self.elements.stickyTrack) {
                self.elements.stickyTrack.style.transition = silent ? 'none' : '';
                self.elements.stickyTrack.style.transform = 'translate3d(' + self.options.offset + 'px,0,0)';
            }

            self.updateClasses();
            self.closeTooltip();
            self.util.updateTrackingData(self.elements.item[self.options.current]);

            if (self.map && !silent) {
                self.calculateRange();

                self.util.trackEvent({element: self.elements.item[self.options.current]});
            }

            //
            clearTimeout(self.options.timeout.silent);
            if (self.options.current >= self.options.count) {
                self.options.timeout.silent = setTimeout(function () {
                    self.slideTo(self.options.current - self.options.count, true);
                }, self.options.animationTiming);
            }

            //
            if (self.options.current < 0) {
                self.slideTo(0, true);
            }

            //
            if(!silent) {
                self.util.setClass(self.elements.slider, {sliding: true});
                clearTimeout(self.options.timeout.sliding);
                self.options.timeout.sliding = setTimeout(function () {
                    self.util.setClass(self.elements.slider, {sliding: false});
                }, self.options.animationTiming);
            }
            if (init === false) {
                self.setConLink(self.options.current);
                self.setTechDataLink(self.options.current);
            }

            self.updateActivityMapTracking();
        };

        /**
         * Close open tooltips
         * check if any tooltips are open and close the corresponding layer
         */
        DS2ElectricRange.prototype.closeTooltip = function() {
            var self = this,
                tooltip = self.element.querySelectorAll('.ds2-tooltip--open');

            if (tooltip.length) self.util.dispatchEvent(tooltip[0], 'ds2-tooltip--close');
        };

        DS2ElectricRange.prototype.updateActivityMapTracking = function () {
            var self = this;

            var mmdr = self.elements.item[self.options.current].dataset.modelRange;
            var carName = self.elements.item[self.options.current].querySelector('.ds2-electric-range__model-card-title').innerText;

            self.element.setAttribute('data-tracking-regionid', `electric range calculator:${mmdr}:${carName}`);
        }

        DS2ElectricRange.prototype.checkPosition = function () {
            var self = this;
            var rangeUnderMapElement = document.querySelector('.ds2-electric-range__show-range-value-for-mobile');
            var map = document.querySelector('.ds2-electric-range__map-wrapper');
            var distance = map.getBoundingClientRect().top;
            if (distance + 120 > 0) {
                rangeUnderMapElement.classList.add('hide-range-value');
                rangeUnderMapElement.setAttribute('aria-hidden', true);
            } else {
                rangeUnderMapElement.classList.remove('hide-range-value');
                rangeUnderMapElement.removeAttribute('aria-hidden');
            }
        }

        return DS2ElectricRange;
    });

/**
 * @module ds2-electric-range-accessibility
 * @description Electric range component Accessibility Partial
 * @author Martin Dimitrov
 */

define(
    'ds2-electric-range-accessibility',
    [
        'ds2-accessibility'
    ],
    function (Accessibility) {
        'use strict';
        function DS2ElectricRangeAccessibility(element, map) {
            var self = this;

            self.accessibility = new Accessibility(element);
            self.element = element;
            self.map = map;
            
            self.elements = {
                driverProfileInputs: element.querySelectorAll('.ds2-electric-range__driving-profile-range input'), 
                getLabels: element.querySelectorAll(".ds2-electric-range__driving-profile-range .electric-range-slider__legend")[1].children,
                closeLayer: element.querySelector('.ds2-electric-range__layer-close'),
                layer: element.querySelector('.ds2-electric-range__layer'),
                layerItems: element.querySelectorAll('.ds2-electric-range__layer-item'),
                map: element.querySelector('.ds2-electric-range__map'),
                mapControls: element.querySelector('.ds2-electric-range__map-controls'),
                zoomOutButton: element.querySelector('.ds2-electric-range__map-zoom').children[1],
                searchBar: element.querySelector('.ds2-electric-range__map-search label input'),
                header: element.querySelector('.ds2-electric-range__layer-header').children[0] 
            };

            // Check which provider is used and add accessibility
            if (self.map.options.api.provider === "google") {
                self.interval = setInterval(() => {
                    var anchors = self.elements.map.getElementsByTagName('a');
                    for (var i = 0; i < anchors.length; i++) {
                        if (anchors[i].href.indexOf('maps.google.com/maps?') !== -1) {
                            clearInterval(self.interval);
                            this.googleMapAccessibility(anchors[i]);
                        }
                    }
                }, 500);
            } else if (self.map.options.api.provider === "yandex") {
                self.interval = setInterval(() => {
                    var yandexMap = self.element.querySelector('.ymaps-2-1-78-events-pane.ymaps-2-1-78-user-selection-none');
                    if (yandexMap) {
                        clearInterval(self.interval);
                        this.yandexMapAccessibility(yandexMap);
                    }
                }, 500);
            }
         
            this.addKeyboardSupportDrivingProfileInput(self.elements.driverProfileInputs);
        }
        
        DS2ElectricRangeAccessibility.prototype.addKeyboardSupportDrivingProfileInput = function (inputs) {
            var self = this;

            var efficient = self.elements.getLabels[0].innerHTML;
            var moderate = self.elements.getLabels[1].innerHTML;
            var sporty = self.elements.getLabels[2].innerHTML;
            var labels = [efficient, efficient + ' ' + moderate, moderate, moderate + ' ' + sporty, sporty];

            inputs.forEach(input => {
                input.addEventListener('change', function (event) {
                    var value = Number(event.target.value);
                    input.setAttribute('aria-valuetext', labels[value - 1]);
                });
            })
        }

        /**
         * - Set layer items focusable
         * - Set close button focusable
         * - Focus first layer item or header
         * - Activate Keyboard Trap
         * - Activate Screen Reader Trap
        */
        DS2ElectricRangeAccessibility.prototype.makeLayerElementsFocusable = function (current) {
            var self = this;

            var event = new Event('click');
            self.elements.layerItems.forEach((item) => {
                self.accessibility.addKeyListener('down', {
                            element: item,
                            keyCodes: [self.accessibility.keyCodes.ENTER],
                            fn: function (el) {
                                el.target.dispatchEvent(event);
                                self.accessibility.setAriaStatus(el.target);
                            },          
                        });
                    self.accessibility.makeElementActive(item);
                    self.accessibility.makeElementReadable(item);
            });
            self.accessibility.makeElementActive(self.elements.closeLayer);

            self.accessibility.focusElement(self.elements.layerItems[current]); 

            self.accessibility.activateKeyboardTrap({container: self.elements.layer, includeContainer: true});
            setTimeout(function () {
                self.screenReaderTrap = self.accessibility.activateScreenReaderTrap(self.elements.layer);
            }, 500);
        };

        /**
         * - Set layer items unfocusable
         * - Set close button unfocusable
         * - Set layer header unfocusable
         * - Deactivate Screen Reader Trap
        */
        DS2ElectricRangeAccessibility.prototype.makeLayerElementsUnFocusable = function () {
            var self = this;

            self.elements.layerItems.forEach((element) => {
                self.accessibility.makeElementInactive(element);
            });
            self.accessibility.makeElementInactive(self.elements.closeLayer);
            self.accessibility.makeElementInactive(self.elements.header);

            setTimeout(function () {
                self.accessibility.deactivateScreenReaderTrap(self.screenReaderTrap);
            }, 500);
        };

        /**
         * - Sets the focus to the given element
        */
        DS2ElectricRangeAccessibility.prototype.focusElement = function (element) {
            var self = this;
           
            self.accessibility.focusElement(element);
        };

        /**
         * - Make given element tabbable for keyboard users
        */
        DS2ElectricRangeAccessibility.prototype.makeElementActive = function (element) {
            var self = this;
           
            self.accessibility.makeElementActive(element);
        };

        /**
         * - Make Google map WCAG compliant
         * - Fix Google link anchor tag
        */
        DS2ElectricRangeAccessibility.prototype.googleMapAccessibility = function (anchorLink) {
            var self = this,
            googleTerms = self.element.querySelector('.gmnoprint.gm-style-cc').querySelector('a'),
            map = self.element.querySelector('.gm-style').children[0];

            map.children[0].ariaHidden = "true";
            map.children[1].ariaHidden = "true";

            anchorLink.style.margin = "0px";
            anchorLink.style.display = "block";

            self.updateMapElements(map, anchorLink, googleTerms);
        };

        /**
         * - Make Yandex map WCAG compliant
         * - Make Yandex map focusable
         * - Set role to Yandex map link
        */
        DS2ElectricRangeAccessibility.prototype.yandexMapAccessibility = function (map) {
            var self = this,
            userAgreement = self.element.querySelector('.ymaps-2-1-78-copyright__link'),
            yandexLink = self.element.querySelector('.ymaps-2-1-78-gotoymaps__container');

            self.accessibility.makeElementActive(map);
            self.accessibility.setAriaRole(yandexLink, "link");

            self.updateMapElements(map, yandexLink, userAgreement);
        };

        /**
         * - Set focus event listeners on map elements
         * - Set elements focusable/unfocusable depending of the current focused element
         * - Change elements order depending of the current focused element
        */
        DS2ElectricRangeAccessibility.prototype.updateMapElements = function (map, link, terms) {
            var self = this;

            map.addEventListener('focus', function() {
                self.accessibility.makeElementInactive(link);
                self.accessibility.makeElementInactive(terms);
                self.accessibility.setLastActiveElement();
            })

            self.elements.searchBar.addEventListener('focus', function() {
                self.accessibility.makeElementActive(map);
                self.accessibility.makeElementInactive(link);
                self.accessibility.makeElementInactive(terms);
                self.accessibility.changeElementOrder(self.elements.map, "before", self.elements.mapControls, true);
            });

            self.elements.zoomOutButton.addEventListener('focus', function() {
                if(self.accessibility.activeElement === map){
                    self.accessibility.makeElementInactive(map);
                    self.accessibility.makeElementActive(link);
                    self.accessibility.makeElementActive(terms);
                    self.accessibility.changeElementOrder(self.elements.map, "after", self.elements.mapControls, true);
                }
            });
        };

        return DS2ElectricRangeAccessibility;
    });

